CVscore
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
CVscore
CVscore$model
data(CVscore)
CVscore$AUC
CVscore$AUC
CVscore
summary(CVscore)
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + poly(log.lvmi, 3), data = data)
summary(augmented_model_2)
# Evaluate the proportional hazards assumption using the cox.zph function
# This function tests the proportional hazards assumption based on the scaled Schoenfeld residuals
ph_test_2 <- cox.zph(augmented_model_2)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_2)  # This generates multiple plots if there are multiple covariates
# Print the global test of proportional hazards
print(ph_test_2) # Displays test statistics and p-values for each covariate
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model,newdata=data)
data$risk_augmented<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
plotCalibration(score,times=5,cens.method="local",method="quantile",q=10)
title(main="Calibration Plot at 5 years")
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model_2,newdata=data)
data$risk_augmented_2<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model_2),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + poly(log.lvmi, 3), data = data, x=T)
summary(augmented_model_2)
# Evaluate the proportional hazards assumption using the cox.zph function
# This function tests the proportional hazards assumption based on the scaled Schoenfeld residuals
ph_test_2 <- cox.zph(augmented_model_2)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_2)  # This generates multiple plots if there are multiple covariates
# Print the global test of proportional hazards
print(ph_test_2) # Displays test statistics and p-values for each covariate
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model_2,newdata=data)
data$risk_augmented_2<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model_2),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
plotCalibration(score,times=5,cens.method="local",method="quantile",q=10)
title(main="Calibration Plot at 5 years")
plotROC(score,times=5,cens.method="local")
title(main="time-dependent ROC at 5 years")
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
summary(CVscore)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model_2,newdata=data)
data$risk_augmented_2<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model_2),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
plotCalibration(score,times=5,cens.method="local",method="quantile",q=10)
title(main="Calibration Plot at 5 years")
plotROC(score,times=5,cens.method="local")
title(main="time-dependent ROC at 5 years")
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"),
split.method="loob",B=100,seed=1000)
summary(CVscore)
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
plotCalibration(CVscore,times=5,cens.method="local",method="quantile",q=10)
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
summary(CVscore)
# Define new patient data
new_patients <- data.frame(
sex = c(0, 1, 0),
age = c(50, 60, 80),
con.cabg = c(1, 0, 1),
creat = c(1.2, 1.5, 1.3),
lv = c(2, 3, 1),
sten.reg.mix = c(1, 3, 2),
log.lvmi = c(2.5, 3.0, 2.7)
)
# Add polynomial terms for log.lvmi for the augmented model
new_patients$log.lvmi_poly <- poly(new_patients$log.lvmi, 3)
# Define new patient data
new_patients <- data.frame(
sex = c(0, 1, 0),
age = c(50, 60, 80),
con.cabg = c(1, 0, 1),
creat = c(1.2, 1.5, 1.3),
lv = c(2, 3, 1),
sten.reg.mix = c(1, 3, 2),
log.lvmi = c(2.5, 3.0, 2.7)
)
# Predict survival probabilities at 5 years (5 years * 365.25 days/year)
surv_times <- 5 * 365.25
# Base model predictions
base_model_preds <- survfit(base_model, newdata = new_patients)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2) # For plotting
library(dplyr) # For data handling
library(readr)
library(survival) # Main library, used for implementing Cox Modeling
library(pROC) # For plotting ROC curves
library(survminer)
library(utils) #For not having to upload the txt each time
library(riskRegression) # For performance indicators
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
dim(data)
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "lightblue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
print(cor_matrix)
if (!require(corrplot)) {
install.packages("corrplot")
library(corrplot)
}
corrplot(cor_matrix, method = "circle")
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot of log.lvmi for Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
# The outcome variable is a survival object created with the time to event (fuyrs) and status indicator (status)
surv_obj <- Surv(data$fuyrs, data$status)
# Perform Cox regression for each predictor
# Excluding paz.id from the analysis as it's an identifier, not a predictor
variables <- c("log.lvmi", "sex", "age", "con.cabg", "creat", "lv", "sten.reg.mix")
# Store results in a list for easy access
univariate_models <- list()
for (var in variables) {
# Formula to dynamically create the regression model
formula <- as.formula(paste("surv_obj ~", var))
# Fit the Cox model
model <- coxph(formula, data = data)
# Print the summary of the model
print(summary(model))
# Store the model in the list
univariate_models[[var]] <- model
}
univariate_models[["log.lvmi"]]
univariate_models[["sex"]]
univariate_models[["age"]]
univariate_models[["con.cabg"]]
univariate_models[["creat"]]
univariate_models[["lv"]]
univariate_models[["sten.reg.mix"]]
base_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix, data = data, x=T)
summary(base_model)
# Evaluate the proportional hazards assumption using cox.zph function
# This function performs a test of proportional hazards based on the scaled Schoenfeld residuals
ph_test <- cox.zph(base_model)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test)  # Multiple plots if more than one covariate; assess each plot for trends over time
# Output the global test of proportional hazards from cox.zph
print(ph_test) # This will display the test statistics and p-values for each covariate
# Check the linearity of continuous variables using Martingale residuals from a null model
null_model <- coxph(Surv(fuyrs, status) ~ 1, data = data) # Null model with no covariates
# Selecting continuous variables to check for non-linearity
continuous_vars <- c("age", "creat")
# Plot Martingale residuals against each continuous variable
for(var in continuous_vars) {
# Plot residuals against continuous variables
plot(data[[var]], residuals(null_model, type = "martingale"), xlab = var, ylab = "Martingale residuals", main = paste("Linearity Check for", var))
abline(h = 0, col = "red")  # Horizontal line at zero to aid in visual assessment
}
augmented_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + log.lvmi, data = data, x=T)
summary(augmented_model)
# Evaluate the proportional hazards assumption using cox.zph function
# This function performs a test of proportional hazards based on the scaled Schoenfeld residuals
ph_test_augmented <- cox.zph(augmented_model)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_augmented)  # Multiple plots if more than one covariate; assess each plot for trends over time
# Output the global test of proportional hazards from cox.zph
print(ph_test_augmented) # This will display the test statistics and p-values for each covariate
# Selecting continuous variables to check for non-linearity
continuous_vars_augmented <- c("age", "creat", "log.lvmi")  # Now including log.lvmi
# Plot Martingale residuals against each continuous variable
for(var in continuous_vars_augmented) {
# Plot residuals against continuous variables
plot(data[[var]], residuals(null_model, type = "martingale"), xlab = var, ylab = "Martingale residuals", main = paste("Linearity Check for", var))
abline(h = 0, col = "red")  # Horizontal line at zero to aid in visual assessment
}
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + poly(log.lvmi, 3), data = data, x=T)
summary(augmented_model_2)
# Evaluate the proportional hazards assumption using the cox.zph function
# This function tests the proportional hazards assumption based on the scaled Schoenfeld residuals
ph_test_2 <- cox.zph(augmented_model_2)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_2)  # This generates multiple plots if there are multiple covariates
# Print the global test of proportional hazards
print(ph_test_2) # Displays test statistics and p-values for each covariate
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model_2,newdata=data)
data$risk_augmented_2<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model_2),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
plotCalibration(score,times=5,cens.method="local",method="quantile",q=10)
title(main="Calibration Plot at 5 years")
plotROC(score,times=5,cens.method="local")
title(main="time-dependent ROC at 5 years")
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
summary(CVscore)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
# Define new patient data
new_patients <- data.frame(
sex = c(0, 1, 0),
age = c(50, 60, 80),
con.cabg = c(1, 0, 1),
creat = c(1.2, 1.5, 1.3),
lv = c(2, 3, 1),
sten.reg.mix = c(1, 3, 2),
log.lvmi = c(2.5, 3.0, 2.7)
)
# Predict survival probabilities at 5 years (5 years * 365.25 days/year)
surv_times <- 5 * 365.25
# Base model predictions
base_model_preds <- survfit(base_model, newdata = new_patients)
# Define new patient data
new_patients <- data.frame(
sex = factor(0, 1, 0),
age = factor(50, 60, 80),
con.cabg = factor(1, 0, 1),
creat = factor(1.2, 1.5, 1.3),
lv = factor(2, 3, 1),
sten.reg.mix = factor(1, 3, 2),
log.lvmi = factor(2.5, 3.0, 2.7)
)
# Predict survival probabilities at 5 years (5 years * 365.25 days/year)
surv_times <- 5 * 365.25
# Base model predictions
base_model_preds <- survfit(base_model, newdata = new_patients)
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + strata(log.lvmi), data = data, x=T)
summary(augmented_model_2)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2) # For plotting
library(dplyr) # For data handling
library(readr)
library(survival) # Main library, used for implementing Cox Modeling
library(pROC) # For plotting ROC curves
library(survminer)
library(utils) #For not having to upload the txt each time
library(riskRegression) # For performance indicators
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
dim(data)
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "lightblue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
print(cor_matrix)
if (!require(corrplot)) {
install.packages("corrplot")
library(corrplot)
}
corrplot(cor_matrix, method = "circle")
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot of log.lvmi for Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
# The outcome variable is a survival object created with the time to event (fuyrs) and status indicator (status)
surv_obj <- Surv(data$fuyrs, data$status)
# Perform Cox regression for each predictor
# Excluding paz.id from the analysis as it's an identifier, not a predictor
variables <- c("log.lvmi", "sex", "age", "con.cabg", "creat", "lv", "sten.reg.mix")
# Store results in a list for easy access
univariate_models <- list()
for (var in variables) {
# Formula to dynamically create the regression model
formula <- as.formula(paste("surv_obj ~", var))
# Fit the Cox model
model <- coxph(formula, data = data)
# Print the summary of the model
print(summary(model))
# Store the model in the list
univariate_models[[var]] <- model
}
univariate_models[["log.lvmi"]]
univariate_models[["sex"]]
univariate_models[["age"]]
univariate_models[["con.cabg"]]
univariate_models[["creat"]]
univariate_models[["lv"]]
univariate_models[["sten.reg.mix"]]
base_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix, data = data, x=T)
summary(base_model)
# Evaluate the proportional hazards assumption using cox.zph function
# This function performs a test of proportional hazards based on the scaled Schoenfeld residuals
ph_test <- cox.zph(base_model)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test)  # Multiple plots if more than one covariate; assess each plot for trends over time
# Output the global test of proportional hazards from cox.zph
print(ph_test) # This will display the test statistics and p-values for each covariate
# Check the linearity of continuous variables using Martingale residuals from a null model
null_model <- coxph(Surv(fuyrs, status) ~ 1, data = data) # Null model with no covariates
# Selecting continuous variables to check for non-linearity
continuous_vars <- c("age", "creat")
# Plot Martingale residuals against each continuous variable
for(var in continuous_vars) {
# Plot residuals against continuous variables
plot(data[[var]], residuals(null_model, type = "martingale"), xlab = var, ylab = "Martingale residuals", main = paste("Linearity Check for", var))
abline(h = 0, col = "red")  # Horizontal line at zero to aid in visual assessment
}
augmented_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + log.lvmi, data = data, x=T)
summary(augmented_model)
# Evaluate the proportional hazards assumption using cox.zph function
# This function performs a test of proportional hazards based on the scaled Schoenfeld residuals
ph_test_augmented <- cox.zph(augmented_model)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_augmented)  # Multiple plots if more than one covariate; assess each plot for trends over time
# Output the global test of proportional hazards from cox.zph
print(ph_test_augmented) # This will display the test statistics and p-values for each covariate
# Selecting continuous variables to check for non-linearity
continuous_vars_augmented <- c("age", "creat", "log.lvmi")  # Now including log.lvmi
# Plot Martingale residuals against each continuous variable
for(var in continuous_vars_augmented) {
# Plot residuals against continuous variables
plot(data[[var]], residuals(null_model, type = "martingale"), xlab = var, ylab = "Martingale residuals", main = paste("Linearity Check for", var))
abline(h = 0, col = "red")  # Horizontal line at zero to aid in visual assessment
}
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + strata(log.lvmi), data = data, x=T)
summary(augmented_model_2)
augmented_model_2 <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + poly(log.lvmi, 3), data = data, x=T)
summary(augmented_model_2)
# Evaluate the proportional hazards assumption using the cox.zph function
# This function tests the proportional hazards assumption based on the scaled Schoenfeld residuals
ph_test_2 <- cox.zph(augmented_model_2)
# Plotting the residuals to visually inspect any trend indicating non-proportionality
plot(ph_test_2)  # This generates multiple plots if there are multiple covariates
# Print the global test of proportional hazards
print(ph_test_2) # Displays test statistics and p-values for each covariate
fit1<-survfit(base_model,newdata=data)
data$risk_base<-1-as.numeric(summary(fit1,times=5)$surv)
fit2<-survfit(augmented_model_2,newdata=data)
data$risk_augmented_2<-1-as.numeric(summary(fit2,times=5)$surv)
score <- Score(list("Base"=base_model,"Augmented"=augmented_model_2),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
plots=c("calibration","ROC"))
plotCalibration(score,times=5,cens.method="local",method="quantile",q=10)
title(main="Calibration Plot at 5 years")
plotROC(score,times=5,cens.method="local")
title(main="time-dependent ROC at 5 years")
CVscore <- Score(list("Base"=base_model,"Augmented"=augmented_model),
formula=Surv(fuyrs, status==1)~1,
data=data,conf.int=T,
times=seq(1,5,1),
split.method="loob",B=100,seed=1000)
summary(CVscore)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = factor(0, 1, 0), age = factor(50, 60, 80), con.cabg = factor(1, 0, 1), creat = factor(1.2, 1.5, 1.3), lv = factor(2, 3, 1), sten.reg.mix = factor(1, 3, 2), log.lvmi = factor(2.5, 3.0, 2.7)), type = "risk", times = 5)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = factor(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
# Predictions for augmented model
predict(augmented_model_2, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
# indicator of death within 5 year
data$status.5y<-ifelse(data$fuyrs<=5,1,0)
# Brier Score
(BS_base <- mean((data$status.5y - data$risk_base) ^ 2))
(BS_augmented <- mean((data$status.5y - data$risk_augmented) ^ 2))
head(data)
# indicator of death within 5 year
data$status.5y<-ifelse(data$fuyrs<=5,1,0)
# Brier Score
(BS_base <- mean((data$status.5y - data$risk_base) ^ 2))
(BS_augmented <- mean((data$status.5y - data$risk_augmented) ^ 2))
head(data)
BS_basesc  <- mean(data$risk_base*(1-data$risk_base))
BS_augmentedsc <- mean(data$risk_augmented*(1-data$risk_augmented))
BS_base-BS_basesc
BS_augmented-BS_augmentedsc
roc1<-roc(data$status.5y, data$risk_base)
plot(1 - roc1$specificities, roc1$sensitivities,
type = 'l', ylab = 'TPF', xlab = 'FPF', lwd = 3, xaxt = "n", yaxt = "n",
xlim = c(0,1), cex.lab = 1.7, frame = F)
axis(1, at = c(0,0.25,0.5,0.75,1), labels = NA, pos = 0)
axis(1, at = c(0,0.25,0.5,0.75,1), labels = c(0,0.25,0.5,0.75,1), cex.axis = 1.7, pos = 0)
axis(2, at = c(0,0.25,0.5,0.75,1), labels = c(0,0.25,0.5,0.75,1), cex.axis = 1.7, pos = 0)
Youden1<-roc1$sensitivities+roc1$specificities-1
optimal.cut.off1<-roc1$thresholds[Youden1==max(Youden1)]
cbind(optimal.cut.off1,Youden=max(Youden1))
points(1-roc1$specificities[roc1$thresholds==optimal.cut.off1],roc1$sensitivities[roc1$thresholds==optimal.cut.off1],pch=0,cex=1.7)
roc2<-roc(data$status.5y, data$risk_augmented)
lines(1 - roc2$specificities, roc2$sensitivities,
lwd = 3, lty = 3)
Youden2<-roc2$sensitivities+roc2$specificities-1
optimal.cut.off2<-roc2$thresholds[Youden2==max(Youden2)]
cbind(optimal.cut.off2,Youden=max(Youden2))
points(1-roc2$specificities[roc2$thresholds==optimal.cut.off2],roc2$sensitivities[roc2$thresholds==optimal.cut.off2],pch=0,cex=1.7)
# Chance line:
abline(a=0, b=1, lty = 2, lwd = 2)
lines(c(0,1), c(1,1), lty = 1)
lines(c(1,1), c(0,1), lty = 1)
legend(x = 0, y = 1, c("model1","model2"), lwd = c(3,3), lty = c(1,3), bty = 'n', cex = 1.7)
bas<-basehaz(base_model,centered=FALSE)
bas.surv<- exp( -bas[,1] )
plot(bas$time, bas.surv, type='s',col=1, ylim=c(0,1) , xlim=c(0,13),lty=2, xlab='time', ylab='survival probability')
surv_patientCP<-bas.surv^(exp(0.1858+ 0.4119 -0.3931 + 0.7019 +0.2385 ))
surv_patientCP<-bas.surv^(exp(0.1858+ 0.4119 -0.3931 + 0.7019 +0.2385 ))
lines(bas$time, surv_patientCP, type='s', lwd=2,col=2)
bas<-basehaz(base_model,centered=FALSE)
bas.surv<- exp( -bas[,1] )
plot(bas$time, bas.surv, type='s',col=1, ylim=c(0,1) , xlim=c(0,13),lty=2, xlab='time', ylab='survival probability')
# CP:treat =2, FIGO= III, Karnofsky Index =80 -> karc=1 & residual tumor size=3 cm ->turesc=1, histotype=3 -> histoc=1
surv_patientCP<-bas.surv^(exp(0.1858+ 0.4119 -0.3931 + 0.7019 +0.2385 ))
lines(bas$time, surv_patientCP, type='s', lwd=2,col=2)
# same result, using survfit:
fit<-survfit(model,newdata=data.frame(treat=2,figo=3,karc=1,turesc=1,histoc=1))
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
bas<-basehaz(base_model,centered=FALSE)
bas
bas.surv<- exp( -bas[,1] )
bas.surv
plot(bas$time, bas.surv, type='s',col=1, ylim=c(0,1) , xlim=c(0,13),lty=2, xlab='time', ylab='survival probability')
lines(bas$time, surv_patientCP, type='s', lwd=2,col=2)
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=factor(0),age=50,con.cabg=factor(1),creat=1.2,lv=factor(2),sten.reg.mix=factor(1),log.lvmi=2.5))
0
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
surv_patientCP<-fit$surv
lines(bas$time, surv_patientCP, type='s', lwd=2,col=2)
# same result, using survfit:
fit<-survfit(base_model,newdata=data.frame(sex=0,age=50,con.cabg=1,creat=1.2,lv=2,sten.reg.mix=1,log.lvmi=2.5))
