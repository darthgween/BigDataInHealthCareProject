# Print the results
model_results
#### Test linearity
# Function to plot Martingale residuals for continuous variables
plot_martingale <- function(variable) {
# Compute residuals
martingale_res <- residuals(base_model, type = "martingale")
# Create a data frame for plotting
plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
# Plot
ggplot(plot_data, aes(x = Variable, y = Residuals)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "loess", color = "red") +
labs(title = paste("Martingale residuals vs", variable),
x = variable,
y = "Martingale Residuals")
}
# Plot Martingale residuals for 'age' and 'creat'
plot_martingale("age")
plot_martingale("creat")
# Function to check proportional hazards using Schoenfeld residuals
check_proportional_hazards <- function(model, data) {
# Calculate Schoenfeld residuals
schoenfeld_res <- cox.zph(model)
# Plot the residuals
plot(schoenfeld_res)
}
# Check proportional hazards
check_proportional_hazards(base_model, data)
# Function to plot Martingale residuals for continuous variables
plot_martingale <- function(variable) {
# Compute residuals
martingale_res <- residuals(base_model, type = "martingale")
# Create a data frame for plotting
plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
# Plot
ggplot(plot_data, aes(x = Variable, y = Residuals)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "loess", color = "red") +
labs(title = paste("Martingale residuals vs", variable),
x = variable,
y = "Martingale Residuals")
}
# Plot Martingale residuals for 'age' and 'creat'
plot_martingale("age")
plot_martingale("creat")
# Function to check proportional hazards using Schoenfeld residuals
check_proportional_hazards <- function(model, data) {
# Calculate Schoenfeld residuals
schoenfeld_res <- cox.zph(model)
# Plot the residuals
plot(schoenfeld_res)
}
# Check proportional hazards
check_proportional_hazards(base_model, data)
# Check the functional form of 'age' using Martingale residuals
mart_resid_age <- resid(base_model, type = "martingale")
plot(data$age, mart_resid_age, xlab = "Age", ylab = "Martingale residuals", main = "Martingale Residuals vs Age")
abline(h = 0, col = "red")
# Check the functional form of 'creat' using Martingale residuals
mart_resid_creat <- resid(base_model, type = "martingale")
plot(data$creat, mart_resid_creat, xlab = "Creatinine Levels", ylab = "Martingale residuals", main = "Martingale Residuals vs Creatinine Levels")
abline(h = 0, col = "red")
# Checking Proportional Hazards assumption
# We use cox.zph function to perform the test
ph_test <- cox.zph(base_model)
print(ph_test)  # This will print the test results
plot(ph_test)   # This plots the Schoenfeld residuals
#### Test Proportional Hazards - Martingale and Schoenfeld
# Function to plot Martingale residuals for continuous variables - FUNCTIONAL FORM
plot_martingale <- function(variable) {
# Compute residuals
martingale_res <- residuals(base_model, type = "martingale")
# Create a data frame for plotting
plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
# Plot
ggplot(plot_data, aes(x = Variable, y = Residuals)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "loess", color = "red") +
labs(title = paste("Martingale residuals vs", variable),
x = variable,
y = "Martingale Residuals")
}
# Plot Martingale residuals for 'age' and 'creat'- FUNCTIONAL FORM
plot_martingale("age")
plot_martingale("creat")
# Function to check proportional hazards using Schoenfeld residuals - PH ASSUMPTION
check_proportional_hazards <- function(model, data) {
# Calculate Schoenfeld residuals
schoenfeld_res <- cox.zph(model)
# Plot the residuals
plot(schoenfeld_res)
}
# Check proportional hazards
check_proportional_hazards(base_model, data)
# Evaluate functional form of continuous variables using Martingale residuals
# Check for 'log.lvmi'
plot(resid(augmented_model, type = "martingale") ~ data$log.lvmi,
xlab = "Log LVMi", ylab = "Martingale Residuals", main = "Martingale Residuals vs Log LVMi")
augmented_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + log.lvmi, data = data)
summary(augmented_model)
# Evaluate functional form of continuous variables using Martingale residuals
# Check for 'log.lvmi'
plot(resid(augmented_model, type = "martingale") ~ data$log.lvmi,
xlab = "Log LVMi", ylab = "Martingale Residuals", main = "Martingale Residuals vs Log LVMi")
abline(h = 0, col = "red")
# Check for 'age'
plot(resid(augmented_model, type = "martingale") ~ data$age,
xlab = "Age", ylab = "Martingale Residuals", main = "Martingale Residuals vs Age")
abline(h = 0, col = "red")
# Check for 'creat'
plot(resid(augmented_model, type = "martingale") ~ data$creat,
xlab = "Creatinine Levels", ylab = "Martingale Residuals", main = "Martingale Residuals vs Creatinine Levels")
abline(h = 0, col = "red")
# Function to plot Martingale residuals for continuous variables - FUNCTIONAL FORM
plot_martingale_aug <- function(variable) {
# Compute residuals
martingale_res <- residuals(augmented_model, type = "martingale")
# Create a data frame for plotting
plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
# Plot
ggplot(plot_data, aes(x = Variable, y = Residuals)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "loess", color = "red") +
labs(title = paste("Martingale residuals vs", variable),
x = variable,
y = "Martingale Residuals")
}
# Plot Martingale residuals for 'age' and 'creat'- FUNCTIONAL FORM
plot_martingale_aug("age")
plot_martingale_aug("creat")
# Check proportional hazards
check_proportional_hazards(augmented_model, data)
# Check for 'log.lvmi'
plot(resid(augmented_model, type = "martingale") ~ data$log.lvmi,
xlab = "Log LVMi", ylab = "Martingale Residuals", main = "Martingale Residuals vs Log LVMi")
abline(h = 0, col = "red")
# Check for 'age'
plot(resid(augmented_model, type = "martingale") ~ data$age,
xlab = "Age", ylab = "Martingale Residuals", main = "Martingale Residuals vs Age")
abline(h = 0, col = "red")
# Check for 'creat'
plot(resid(augmented_model, type = "martingale") ~ data$creat,
xlab = "Creatinine Levels", ylab = "Martingale Residuals", main = "Martingale Residuals vs Creatinine Levels")
abline(h = 0, col = "red")
plot_martingale_aug("log.lvmi")
# Check the proportional hazards assumption for the augmented model
cox.zph(augmented_model)
# Plot the Schoenfeld residuals for the augmented model
plot(cox.zph(augmented_model))
# Check proportional hazards
check_proportional_hazards(augmented_model, data)
# Plot the residuals
plot(cox.zph(model))
# Plot the residuals
plot(cox.zph(base_model))
# Example of Kaplan-Meier curves for the augmented model
ggsurvplot(survfit(augmented_model), data = data, risk.table = TRUE)
# Predictions for augmented model
predict(augmented_model, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
View(augmented_model)
View(univariate_models)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(readr)
library(survival)
library(survminer)
library(randomForestSRC)
library(gbm)
library(utils) #For not having to upload the txt each time
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
#TO EVALUATE
# data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
# data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
# data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
# data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
dim(data)
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
print(cor_matrix)
if (!require(corrplot)) {
install.packages("corrplot")
library(corrplot)
}
corrplot(cor_matrix, method = "circle")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot di log.lvmi per Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
univariate_models <- lapply(names(data)[-1], function(var) {
cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
return(list(variable = var, model = cox_model))
})
univariate_models <- lapply(names(data)[-1], function(var) {
cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
return(list(variable = var, model = cox_model))
})
for (item in univariate_models) {
print(item$variable)
print(summary(item$model))
}
print(univariate_models[[1]]$variable)
print(summary(univariate_models[[1]]$model))
print(univariate_models[[2]]$variable)
print(summary(univariate_models[[2]]$model))
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(readr)
library(survival)
library(survminer)
library(randomForestSRC)
library(gbm)
library(utils) #For not having to upload the txt each time
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
#TO EVALUATE
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
dim(data)
str(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot di log.lvmi per Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
univariate_models <- lapply(names(data)[-1], function(var) {
cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
return(list(variable = var, model = cox_model))
})
for (item in univariate_models) {
print(item$variable)
print(summary(item$model))
}
print(univariate_models[[1]]$variable)
print(summary(univariate_models[[1]]$model))
print(univariate_models[[2]]$variable)
print(summary(univariate_models[[2]]$model))
print(univariate_models[[3]]$variable)
print(summary(univariate_models[[3]]$model))
print(univariate_models[[4]]$variable)
print(summary(univariate_models[[4]]$model))
base_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix, data = data)
summary(base_model)
# Evaluate the performance of the models
# For calibration, discrimination, and Net Benefit, you can use specific methods like Kaplan-Meier curves, calibration plots, concordance index (C-index), and decision curve analysis (DCA).
# Example of Kaplan-Meier curves for the base model
ggsurvplot(survfit(base_model), data = data, risk.table = TRUE)
# TRYING CALIBRATION PLOTS
library(survival)
library(rms)
library(ggplot2)
install.packages('survAUC')
library(survAUC)
library(rms)
# Create a calibration plot
calib <- calibrate(base_model, method = "boot", B = 100)
# TRYING CALIBRATION PLOTS
library(survival)
library(rms)
library(ggplot2)
install.packages('survAUC')
library(survAUC)
library(rms)
# Create a calibration plot
calib <- calibrate(base_model, method = "boot", B = 100)
#### Test Proportional Hazards - Martingale and Schoenfeld
# Function to plot Martingale residuals for continuous variables - FUNCTIONAL FORM
plot_martingale <- function(variable) {
# Compute residuals
martingale_res <- residuals(base_model, type = "martingale")
# Create a data frame for plotting
plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
# Plot
ggplot(plot_data, aes(x = Variable, y = Residuals)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "loess", color = "red") +
labs(title = paste("Martingale residuals vs", variable),
x = variable,
y = "Martingale Residuals")
}
# Plot Martingale residuals for 'age' and 'creat'- FUNCTIONAL FORM
plot_martingale("age")
plot_martingale("creat")
# Function to check proportional hazards using Schoenfeld residuals - PH ASSUMPTION
# Plot the residuals
plot(cox.zph(base_model))
# Prediction of event risk at a fixed time-point (e.g., 5 years) for three subjects
# You can predict the survival probability for specific subjects using the predict function.
predict(base_model, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 70), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
augmented_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + log.lvmi, data = data)
summary(augmented_model)
summary(data)
univariate_models <- lapply(names(data)[-1], function(var) {
cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
return(list(variable = var, model = cox_model))
})
for (item in univariate_models) {
print(item$variable)
print(summary(item$model))
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(readr)
library(survival)
library(survminer)
library(randomForestSRC)
library(gbm)
library(utils) #For not having to upload the txt each time
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
#TO EVALUATE
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
dim(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot di log.lvmi per Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot di log.lvmi per Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(readr)
library(survival)
library(survminer)
library(randomForestSRC)
library(gbm)
library(utils) #For not having to upload the txt each time
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
#TO EVALUATE
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
dim(data)
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
ggtitle("Distribuzione dell'età") +
xlab("Età") +
ylab("Frequenza")
cor_matrix <- cor(data, use = "complete.obs")
cor_matrix <- cor(data, use = "complete.obs")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot di log.lvmi per Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
ggplot(data, aes(x = age, y = log.lvmi)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
ggtitle("Scatter Plot: età vs log.lvmi") +
xlab("Età") +
ylab("log.lvmi")
univariate_models <- lapply(names(data)[-1], function(var) {
cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
return(list(variable = var, model = cox_model))
})
for (item in univariate_models) {
print(item$variable)
print(summary(item$model))
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2) # For plotting
library(dplyr) # For data handling
library(readr)
library(survival) # Main library, used for implementing Cox Modeling
library(pROC) # For plotting ROC curves
install.packages("pROC")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2) # For plotting
library(dplyr) # For data handling
library(readr)
library(survival) # Main library, used for implementing Cox Modeling
library(pROC) # For plotting ROC curves
library(survminer)
library(utils) #For not having to upload the txt each time
#library(riskRegression) # For performance indicators
#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
dim(data)
str(data)
summary(data)
ggplot(data, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "lightblue", color = "black") +
ggtitle("Age distribution") +
xlab("Età") +
ylab("Frequenza")
sum_males <- sum(data$sex == 0)
sum_females <- sum(data$sex == 1)
cat("Number of males:", sum_males, "\n")
cat("Number of females:", sum_females, "\n")
#data$sex <- factor(data$sex, levels = c(0, 1), labels = c("M", "F")
ggplot(data, aes(x = sex, fill = sex)) +
geom_bar() +
scale_fill_manual(values = c("Male" = "blue", "Female" = "pink")) +
xlab("Sex") +
ylab("Count") +
ggtitle("Distribution by Sex") +
theme_minimal()
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))
library(corrplot)
# Escludo colonna "paz.id"
numeric_data <- data %>%
select(-paz.id) %>%
select_if(is.numeric)
# Compute correlation matrix
cor_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45, addCoef.col = "black")
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
geom_boxplot() +
ggtitle("Boxplot of log.lvmi for Status") +
xlab("Status") +
ylab("log.lvmi") +
scale_fill_discrete(name = "Status")
# The outcome variable is a survival object created with the time to event (fuyrs) and status indicator (status)
surv_obj <- Surv(data$fuyrs, data$status)
# Perform Cox regression for each predictor
# Excluding paz.id from the analysis as it's an identifier, not a predictor
variables <- c("log.lvmi", "sex", "age", "con.cabg", "creat", "lv", "sten.reg.mix")
# Store results in a list for easy access
univariate_models <- list()
for (var in variables) {
# Formula to dynamically create the regression model
formula <- as.formula(paste("surv_obj ~", var))
# Fit the Cox model
model <- coxph(formula, data = data)
# Print the summary of the model
print(summary(model))
# Store the model in the list
univariate_models[[var]] <- model
}
