---
title: "data.data"
output:
  html_document:
    df_print: paged
---

# Library

```{r}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(readr)
library(survival)
library(survminer)
library(randomForestSRC)
library(gbm)
library(utils) #For not having to upload the txt each time


```

# Importing Data

```{r}

#setwd('~/Desktop/Data Science/Data Science Lab in Medicine/Big Data in Health Care/')
url <- "https://raw.githubusercontent.com/darthgween/BigDataInHealthCareProject/main/heart.valve.txt?token=GHSAT0AAAAAACR3GYSXO5Z3ARKVQY2S6SYSZRYZQWA"
data <- read.table(url, header = TRUE)
head(data)
```

```{r}

#TO EVALUATE
data$sex <- factor(data$sex, levels = c(0, 1), labels = c("Male", "Female"))
data$con.cabg <- factor(data$con.cabg, levels = c(0, 1), labels = c("No", "Yes"))
data$lv <- factor(data$lv, levels = c(1, 2, 3), labels = c("High", "Moderate", "Low"))
data$sten.reg.mix <- factor(data$sten.reg.mix, levels = c(1, 2, 3), labels = c("Stenosis", "Regurgitation", "Mixed"))

```


```{r}
dim(data)
```

Description of dataset variables:

-   ***Paz.id***: patient identification number.

-   ***log.lvmi***: natural logarithm of the “Left Ventricular Mass Index” (standardized) measured at baseline.

-   ***fuyrs***: follow-up time from surgery, in years.

-   ***status***: event indicator (1 = dead; 0 = censored).

-   ***sex***: sex of the patient (0 = M; 1 = F).

-   ***age***: age of the patient (years) at surgery.

-   ***con.cabg***: presence of coronary bypass (1 = yes; 0 = no).

-   ***creat***: pre-operative serum creatinine (µmol/mL).

-   ***lv***: pre-operative left ventricular ejection fraction (1 = high, 2 = moderate, 3 = low).

-   ***sten.reg.mix***: hemodynamics of the heart valve (1 = stenosis, 2 = regurgitation, 3 = mixed).

```{r}
str(data)
```

```{r}
summary(data)
```

# Age distribution

```{r}
ggplot(data, aes(x = age)) +
  geom_histogram(binwidth = 5, fill = "blue", color = "black") +
  ggtitle("Distribuzione dell'età") +
  xlab("Età") +
  ylab("Frequenza")
```

#Correlation between variables

```{r}
cor_matrix <- cor(data, use = "complete.obs")
print(cor_matrix)

if (!require(corrplot)) {
    install.packages("corrplot")
    library(corrplot)
}
corrplot(cor_matrix, method = "circle")
```

## Left Ventricular Mass Index

Il Left Ventricular Mass Index (LVMI) è un parametro clinico utilizzato per valutare la massa del ventricolo sinistro del cuore in relazione alla superficie corporea del paziente. È una misura importante nella diagnosi e nel monitoraggio di condizioni cardiache come l'ipertrofia ventricolare sinistra, che è un ispessimento delle pareti del ventricolo sinistro del cuore.

```{r}
ggplot(data, aes(x = factor(status), y = log.lvmi, fill = factor(status))) +
  geom_boxplot() +
  ggtitle("Boxplot di log.lvmi per Status") +
  xlab("Status") +
  ylab("log.lvmi") +
  scale_fill_discrete(name = "Status")

```

```{r}
ggplot(data, aes(x = age, y = log.lvmi)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  ggtitle("Scatter Plot: età vs log.lvmi") +
  xlab("Età") +
  ylab("log.lvmi")

```

# Models:

```{r}
univariate_models <- lapply(names(data)[-1], function(var) {
  cox_model <- coxph(Surv(fuyrs, status) ~ data[[var]], data = data)
  return(list(variable = var, model = cox_model))
})

```

```{r}
for (item in univariate_models) {
  print(item$variable)
  print(summary(item$model))
  
}

```

```{r}
  print(univariate_models[[1]]$variable)
  print(summary(univariate_models[[1]]$model))
```

```{r}
  print(univariate_models[[2]]$variable)
  print(summary(univariate_models[[2]]$model))
```


```{r}
  print(univariate_models[[3]]$variable)
  print(summary(univariate_models[[3]]$model))
```


```{r}
  print(univariate_models[[4]]$variable)
  print(summary(univariate_models[[4]]$model))
```


```{r}
  print(univariate_models[[5]]$variable)
  print(summary(univariate_models[[5]]$model))
```


```{r}
  print(univariate_models[[6]]$variable)
  print(summary(univariate_models[[6]]$model))
```


```{r}
  print(univariate_models[[7]]$variable)
  print(summary(univariate_models[[7]]$model))
```


```{r}
  print(univariate_models[[8]]$variable)
  print(summary(univariate_models[[8]]$model))
```


```{r}
  print(univariate_models[[9]]$variable)
  print(summary(univariate_models[[9]]$model))
```

## Base model

```{r}
base_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix, data = data)
summary(base_model)


```
The Cox proportional hazards model shows significant effects of age, coronary artery bypass grafting (con.cabg), left ventricular function (lv), and stenosis severity (sten.reg.mix) on survival time. 

Sex and creatinine levels (creat) do not appear to significantly affect survival. 

The model has moderate predictive accuracy (Concordance = 0.783) and overall good fit according to model fit tests. 


```{r}
# Evaluate the performance of the models
# For calibration, discrimination, and Net Benefit, you can use specific methods like Kaplan-Meier curves, calibration plots, concordance index (C-index), and decision curve analysis (DCA).

# Example of Kaplan-Meier curves for the base model
ggsurvplot(survfit(base_model), data = data, risk.table = TRUE)

```

```{r}
# TRYING CALIBRATION PLOTS
library(survival)
library(rms)
library(ggplot2)
install.packages('survAUC')
library(survAUC)
library(rms)

# Create a calibration plot
calib <- calibrate(base_model, method = "boot", B = 100)
calib_plot <- ggplot(calib, aes(x = .score, y = .cal)) +
  geom_line() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(x = "Predicted Risk", y = "Observed Risk", title = "Calibration Plot")

# Print the calibration plot
print(calib_plot)

# Calculate the Brier score
brier_score <- brier.score(Surv(time, status) ~ predict(base_model), data = data, method = "KM")
print(paste("Brier Score: ", brier_score))
```

```{r}
#### Test Proportional Hazards - Martingale and Schoenfeld

# Function to plot Martingale residuals for continuous variables - FUNCTIONAL FORM
plot_martingale <- function(variable) {
  # Compute residuals
  martingale_res <- residuals(base_model, type = "martingale")
  
  # Create a data frame for plotting
  plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
  
  # Plot
  ggplot(plot_data, aes(x = Variable, y = Residuals)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "loess", color = "red") +
    labs(title = paste("Martingale residuals vs", variable),
         x = variable,
         y = "Martingale Residuals")
}

# Plot Martingale residuals for 'age' and 'creat'- FUNCTIONAL FORM
plot_martingale("age")
plot_martingale("creat")

# Function to check proportional hazards using Schoenfeld residuals - PH ASSUMPTION

# Plot the residuals
plot(cox.zph(base_model))



```

```{r}
# Prediction of event risk at a fixed time-point (e.g., 5 years) for three subjects
# You can predict the survival probability for specific subjects using the predict function.

predict(base_model, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 70), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
```

## Augmented model

```{r}
augmented_model <- coxph(Surv(fuyrs, status) ~ sex + age + con.cabg + creat + lv + sten.reg.mix + log.lvmi, data = data)

summary(augmented_model)

```


The augmented model includes log.lvmi as a new predictor, significantly improving predictive accuracy and model fit compared to the base model. Notably, con.cabg and sten.reg.mix show stronger effects, while log.lvmi emerges as a significant predictor. The concordance value (0.797) is slightly higher than the base_model so we can conclude that the augmented one with the new covariate log.lvmi is a better model


```{r}
# Evaluate functional form of continuous variables using Martingale residuals

# Function to plot Martingale residuals for continuous variables - FUNCTIONAL FORM
plot_martingale_aug <- function(variable) {
  # Compute residuals
  martingale_res <- residuals(augmented_model, type = "martingale")
  
  # Create a data frame for plotting
  plot_data <- data.frame(Variable = data[[variable]], Residuals = martingale_res)
  
  # Plot
  ggplot(plot_data, aes(x = Variable, y = Residuals)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "loess", color = "red") +
    labs(title = paste("Martingale residuals vs", variable),
         x = variable,
         y = "Martingale Residuals")
}

# Plot Martingale residuals for 'age', 'creat' and 'log.lvmi' - FUNCTIONAL FORM
plot_martingale_aug("age")
plot_martingale_aug("creat")
plot_martingale_aug("log.lvmi")

```

```{r}
# Check the proportional hazards assumption for the augmented model
cox.zph(augmented_model)


# Plot the Schoenfeld residuals for the augmented model
plot(cox.zph(augmented_model))
```

```{r}

# Example of Kaplan-Meier curves for the augmented model
ggsurvplot(survfit(augmented_model), data = data, risk.table = TRUE)

```

```{r}

# Predictions for augmented model
predict(augmented_model, newdata = data.frame(sex = c(0, 1, 0), age = c(50, 60, 80), con.cabg = c(1, 0, 1), creat = c(1.2, 1.5, 1.3), lv = c(2, 3, 1), sten.reg.mix = c(1, 3, 2), log.lvmi = c(2.5, 3.0, 2.7)), type = "risk", times = 5)
```

## Random Survival Forest model
```{r}
library(randomForestSRC)

# Fit Random Survival Forest model
rsf_model <- rfsrc(Surv(fuyrs, status) ~ ., data = data)

# Summary of the Random Survival Forest model
print(rsf_model)

```

##Gradient Boosting Machine

```{r}

# Fit Gradient Boosting Machine model
gbm_model <- gbm(Surv(fuyrs, status) ~ ., data = data, distribution = "coxph")

# Summary of the Gradient Boosting Machine model
print(gbm_model)

```

##Models Comparison
```{r}

rsf_pred <- predict(rsf_model, data)$predicted
gbm_pred <- predict(gbm_model, data, type = "response")
# Calculate concordance index (C-index) for each model
cindex_rsf <- concordance(Surv(fuyrs, status) ~ rsf_pred, data)$concordance
cindex_gbm <- concordance(Surv(fuyrs, status) ~ gbm_pred, data)$concordance

# Print C-index for each model

cat("Random Survival Forest C-index:", cindex_rsf, "\n")
cat("Gradient Boosting Machine C-index:", cindex_gbm, "\n")

```

##ALEX TEST

```{r}
# Function to run univariate Cox model and return summary
run_cox_model <- function(variable) {
  formula <- as.formula(paste("Surv(fuyrs, status) ~", variable))
  model <- coxph(formula, data = data)
  summary(model)
}

# List of variables to test
variables <- c("log.lvmi", "sex", "age", "con.cabg", "creat", "lv", "sten.reg.mix")

# Apply the function to each variable and store results
model_results <- lapply(variables, run_cox_model)

# Print the results
model_results



```


